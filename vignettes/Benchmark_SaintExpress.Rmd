---
title: "Benchmark Saint Express"
author: "Witold Wolski"
date: "12/2/2021"
output: 
  html_document:
    toc: true
    toc_depth: 2
    toc_float:
      toc_collapsed: false
papersize: a4
geometry: margin=.5in
vignette: >
  %\VignetteIndexEntry{Benchmarking normalization, aggregation and models using the Ionstar Dataset} 
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}

---



```{r setup, include=FALSE}
evalAll <- TRUE
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning = FALSE)
```

# Importing MQ data into proLFQua


First read data and annotation.

```{r fromPeptideTXT , eval = evalAll}
library(prolfqua)
library(tidyverse)
datadir <- file.path(find.package("prolfquaData") , "quantdata")
inputMQfile <-  file.path(datadir,
                          "MAXQuant_IonStar2018_PXD003881.zip")
data <- tidyMQ_Peptides(inputMQfile)

inputAnnotation <- file.path(datadir, "annotation_Ionstar2018_PXD003881.xlsx")
annotation <- readxl::read_xlsx(inputAnnotation)
```

Create proLFQua configruation for MQ peptide.txt file and annotate data. 

```{r}
config <- prolfqua::create_config_MQ_peptide()
res <- add_annotation(
  data,
  annotation,
  fileName = "raw.file"
)

config$table$factors[["dilution."]] = "sample"
config$table$factors[["run_Id"]] = "run_ID"
config$table$factorDepth <- 1
data <- setup_analysis(res, config)
```

Setup LFQData class, filter, transform and aggregate peptide intensities:
- remove proteins with only one peptide identified (`filter_proteins_by_peptide_count`).
- remove small (zero) intensities (`remove_small_intensities`)
- log2 transform and scale intensities (`get_Transformer`)
- aggregate peptides to proteins (`get_Aggregator`)

```{r}

lfqdata <- LFQData$new(data,config)
lfqdata$data <- lfqdata$data %>% filter(!grepl("^REV__|^CON__", protein_Id)) 
lfqdata$filter_proteins_by_peptide_count()
lfqdata$hierarchy_counts()
lfqdata$remove_small_intensities()

tr <- lfqdata$get_Transformer()
subset_h <- lfqdata$get_copy()
subset_h$data <- subset_h$data %>% dplyr::filter(grepl("HUMAN", protein_Id))
subset_h <- subset_h$get_Transformer()$log2()$lfq
lfqdataNormalized <- tr$log2()$robscale_subset(lfqsubset = subset_h)$lfq

lfqAggMedpol <- lfqdataNormalized$get_Aggregator()
lfqAggMedpol$medpolish()
lfqtrans <- lfqAggMedpol$lfq_agg
```

# Prepare protein data for SaintExpress analysis and run SaintExpress

- Specify control and treatment samples using `case_when`
- add protein lengths (`readPeptideFasta`,`addProteinLengths`)
- create SaintExpress compatible inputs (`protein_2localSaint`)
- run saintExpress (`runSaint`)


```{r}

exampleDat <- lfqtrans$data %>% dplyr::mutate(CorT = case_when(dilution. == "a" ~ "C", TRUE ~ "T"))
exampleDat$protein_Id <- gsub("~.*","", exampleDat$protein_Id)

# sample protein lengths


Ecolifasta <- system.file("fastaDBs/uniprot-proteome_UP000000625_reviewed_yes.fasta.gz",package = "prolfquaData")
Humanfasta <- system.file("fastaDBs/uniprot-proteome_UP000005640_reviewed_yes.fasta.gz",package = "prolfquaData")

Ecolifasta <- prozor::readPeptideFasta(Ecolifasta)
Humanfasta <- prozor::readPeptideFasta(Humanfasta)
fasta <- c(Ecolifasta, Humanfasta)
names(fasta)[1:10]

exampleDat <- prolfqua::addProteinLengths(exampleDat, fasta)



res <- protein_2localSaint(exampleDat,quantcolumn = "medpolish",
                           proteinID = "protein_Id",
                           proteinLength = "protein.length",
                           IP_name = "raw.file",
                           baitCol = "dilution.",
                           CorTCol = "CorT"
)
stopifnot(names(res) == c( "inter", "prey",  "bait"))
resSaint <- runSaint(res,filedir = tempdir())

```

# Saint Express BFDR.

SaintExpress infers several statistics.
- the SaintScore - Saint Probability, vaguely - probability that the protein is an interactor.
- the BFDR Bayesian FDR.



The following article [http://varianceexplained.org/r/bayesian_fdr_baseball/] describes how the BFDR can be derived from the posterior error probability (PEP).
The BFDR equals the cumulative mean of the PEP.

SaintExpress does not report the PEP. But assuming that $PEP = 1 - SaintScore$ we can comput the BFDR:

```{r }


computeFDR <- function(mdata ){
    mdata <- dplyr::mutate(mdata, PEP = 1 - SaintScore)
    mdata <- mdata %>% arrange(PEP)
    mdata <- mdata %>% mutate( myFDR = cummean(PEP))
    return(mdata)
}
```

There are two options, either to determine the BFDR for all Baits (first code snipped) or for each Bait (second one with the `for` loop).

```{r fig.cap="BFDR vs myFDR for all Baits."}
reslist <- resSaint$list

reslist <- computeFDR(reslist)
ggplot(reslist, aes(x= BFDR, y = myFDR)) + geom_point() + geom_abline(slope=1,color="red")
```


```{r fig.cap = "BFDR vs myFDR for each Bait."}
ad <- list()
for(i in unique(reslist$Bait)){
    print(i)
    set <- filter(reslist, Bait == i)
    ad[[i]] <- computeFDR(set)
}
ad <- bind_rows(ad)

ggplot(ad, aes(x = BFDR, y = myFDR)) + geom_point() + facet_wrap(~Bait) + ggplot2::geom_abline(slope=1,colour=2)
```

The SE BFDR is quite similar to the FDR we estimated from the SaintScore. It also seems that SaintExpress computes the BFDR for all Baits not for each.


## Benchmarking

Here we benchmark SaintExpress using the Ionstar dataset. We are using here the lowest ECOLI spike in concentration as control.

```{r setUPBenchmark, eval = evalAll}
bb <- ctr$get_contrasts()
bb <- mutate(bb , PEP = 1-SaintScore)
ttd <- prolfqua::ionstar_bench_preprocess( bb , idcol = "Prey" )
benchmark_SaintExpres <- make_benchmark(ttd$data,
                                   contrast = "Bait",
                                fcestimate = "log2FC",
                                toscale = NULL,
                                benchmark = list(
                                  list(sc = "log2FC", desc = TRUE),    
                                  list(sc = "SaintScore", desc = TRUE),
                                  list(sc = "BFDR", desc = FALSE)
                                ),  
                                model_description = "SaintExpress_medpolishInt",
                                model_name = "SaintExpress_medpolishInt",
                                FDRvsFDP = list(list(sc = "BFDR", desc = FALSE))
, hierarchy = c("Prey"), summarizeNA = "SaintScore"
)
colnames(ttd$data)
sum(benchmark_proDA$smc$summary$Prey)
sumarry <- benchmark_proDA$smc$summary
table_facade(sumarry, caption = "nr of proteins with 0, 1, 2, 3 missing contrasts.")

```


```{r prepBenchmarkforComparison, include= FALSE, eval = evalAll}
xdd <- ttd$data %>% dplyr::rename(protein_Id = Prey ,
                                  contrast = Bait,
                                  estimate = log2FC,
                                  statistic = SaintScore,
                                  p.value = PEP,
                                  FDR = BFDR  
)

benchmark2_SaintExpress <- make_benchmark(xdd, model_description = "SaintExpress_medpolishInt", model_name = "proDA")
```

```{r eval=FALSE, include=FALSE}
saveRDS(benchmark_SaintExpres, file = "../inst/Benchresults/benchmark_medpolish_proDA.RDS")

```

```{r rocCurve, fig.cap="ROC curves", eval = evalAll}
res <- benchmark_proDA$pAUC_summaries()
knitr::kable(res$ftable$content,caption = res$ftable$caption)
res$barp
```

```{r pAUC02, fig.cap="plot ROC curves", eval = evalAll}
#res$ftable
benchmark_SaintExpres$plot_ROC(xlim = 0.2)
```

```{r fdrfdp, fig.cap = "plot FDR vs FDP",eval = evalAll}
benchmark_SaintExpres$plot_FDRvsFDP()
```

```{r fdptpr,eval = evalAll}
benchmark_SaintExpres$plot_FDPvsTPR()
```

# Conclusions

Please do compare the scores reported here with those obtained from proLFQua or proDA.


